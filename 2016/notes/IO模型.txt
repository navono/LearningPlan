同步和异步指的是应用程序和内核的交互方式，也就是内核的消息通知机制。
同步是指用户进程触发IO操作后，【等待（IO操作阻塞）】返回结果或者【轮询查看（IO操作非阻塞）】IO操作是否就绪；
由应用程序去等待IO操作是否完成。

异步是指用户进程触发IO操作后，操作立即返回，用户进程可以继续执行自己的其他任务。当IO操作在内核完成后
由内核通过通知机制（状态、回调、消息）去通知应用程序。

阻塞和非阻塞指的是应用程序在等待（IO操作处理结果的）消息通知时的状态。
阻塞是指IO操作的结果返回之前，应用程序的触发IO操作的线程会被挂起，一直处于等待消息通知，不能够执行其他任务。
非阻塞是指不能立刻得到IO操作结果之前，触发IO操作的线程不会被阻塞。


同步阻塞：
用户进程发起一个IO操作，不立即返回，必须等待内核IO操作完成后才知道处理结果。在此期间，操作线程是阻塞的，无法处理其他消息。

同步非阻塞：
用户进程发起一个IO操作，立即返回，但是必须定时轮询内核IO操作是否完成。

异步阻塞：
用户进程发起一个IO操作，立即返回，等内核IO操作完成以后会主动通知用户进程。但是在等待内核通知则是阻塞的，例如调用select
函数则会造成当前线程阻塞，不能处理其他事情，直到有消息通知为止。

异步非阻塞：
用户进程发起一个IO操作，立即返回，等内核IO操作完成以后会主动通知用户进程。内核通过回调、消息等机制通知用户进程，在此
期间，用户进程可以做其他的事情。


综上所述，同步和异步是相对于应用和内核的交互方式而言的，同步 需要主动去询问，
而异步的时候内核在IO事件发生的时候通知应用程序，
而阻塞和非阻塞仅仅是系统在调用系统调用的时候函数的实现方式而已。



同步阻塞IO中，线程实际上等待的时间可能包括两个部分：一个是等待数据就绪；另一个是等待数据的复制。
同步非阻塞IO的调用不会等待数据的就绪，如果数据不可读或不可写，会立即返回。因此需要轮询去检查数据的就绪状态。


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
Reactor模式：IO多路复用（select）【异步阻塞IO模型，阻塞在select上】
Proactor模式：异步IO

Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，
而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，
操作系统会读取缓存区或者写入缓存区到真正的IO设备.



